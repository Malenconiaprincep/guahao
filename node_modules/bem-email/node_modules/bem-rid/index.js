'use strict';

let sha1 = require('bem-sha1');

/* @flow */

const crypto = require('crypto');

// Returns a new random hex string of the given even size.
function randomHexString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomHexString is useless.');
  }
  if (size % 2 !== 0) {
    throw new Error('randomHexString size must be divisible by 2.')
  }
  return crypto.randomBytes(size / 2).toString('hex');
}

// Returns a new random alphanumeric string of the given size.
//
// Note: to simplify implementation, the result has slight modulo bias,
// because chars length of 62 doesn't divide the number of all bytes
// (256) evenly. Such bias is acceptable for most cases when the output
// length is long enough and doesn't need to be uniform.
function randomString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomString is useless.');
  }
  let chars = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
    'abcdefghijklmnopqrstuvwxyz' +
    '0123456789');
  let objectId = '';
  let bytes = crypto.randomBytes(size);
  for (let i = 0; i < bytes.length; ++i) {
    objectId += chars[bytes.readUInt8(i) % chars.length];
  }
  return objectId;
}

function randomBase36String(size) {
  if (size === 0) {
    throw new Error('Zero-length randomString is useless.');
  }
  let chars = ('abcdefghijklmnopqrstuvwxyz' +
    '0123456789');
  let objectId = '';
  let bytes = crypto.randomBytes(size);
  for (let i = 0; i < bytes.length; ++i) {
    objectId += chars[bytes.readUInt8(i) % chars.length];
  }
  return objectId;
}

let rid = function(options) {
  options = options || {};
  let length = options.length || 8;
  let radix = options.radix;
  if (radix === 16) {
    return randomHexString(length);
  }
  if (radix === 62) {
    return randomString(length);
  }
  return randomBase36String(length);
}

module.exports = rid;
